{"version":3,"sources":["footer/index.js","header/index.js","network/node.js","_api/index.js","network/index.js","util.js","main/index.js","App.js","config.js","serviceWorker.js","index.js"],"names":["Footer","className","Component","Header","onChange","event","network_id","target","value","props","onNetworkSelected","this","networks","map","n","key","id","name","to","href","rel","disabled","renderOptions","Node","onDragMove","e","x","y","setPosition","RV","onDragEnd","onStateToggled","state","node","titleHeight","stateOffset","stateHeight","statePadding","width","height","computeHeight","position","probabilities","query","remaining_width","states","idx","probability","bar_width","bar_color","toFixed","text","padding","fontSize","wrap","ellipsis","fill","align","length","center","corners","createStates","draggable","cornerRadius","shadowBlur","fontStyle","api","_axios","_user","config","sessionToken","URLSearchParams","window","location","search","get","_config","withCredentials","axios","create","interceptors","request","use","params","session_token","createAuthRefreshInterceptor","failedRequest","refreshAuthLogic","console","log","then","r","data","_request","url","method","network","parameters","Edge","src","dst","points","pointerLength","pointerWidth","stroke","strokeWidth","getNodeNamesFromNetwork","nodes","intersect","x1","y1","x2","y2","x3","y3","x4","y4","warn","denominator","ua","ub","compute_intersection","line","intersection","p","key1","key2","Network","onNodeMove","nodeAttrsToState","onNodeMoved","saveNetwork","q","history","push","pathname","toString","first_pass_complete","node_centers","node_corners","myRefs","setNetwork","updateFromQueryParameters","array","qs","parse","ignoreQueryPrefix","reduce","obj","item","Object","entries","includes","getNetwork","response","json","setState","queryNetwork","nodenames","current","srcRV","dstRV","src_center","dst_center","src_corners","dst_corners","edges","computeEdge","renderLoading","a","renderEdges","React","createRef","ref","Main","App","path","component","api_config","urlParams","host","port","Boolean","hostname","match","init","ReactDOM","render","basename","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.8ad95566.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './stylesheet.scss';\n\nexport default class Footer extends Component {\n\n\n    render() {\n        return (\n            <div className=\"Footer\">\n                Copyright Â© 2020 Melle Sieswerda. All rights reserved.\n            </div>\n        );\n    }\n}","import React, { Component } from 'react';\nimport { Link } from \"react-router-dom\";\n\nimport './stylesheet.scss';\n\nexport default class Header extends Component {\n\n    onChange = (event) => {\n        // console.log(\"Header::onChange(): \", event.target.value);\n        const network_id = event.target.value;\n        this.props.onNetworkSelected(network_id);\n    }\n\n    renderOptions() {\n        return this.props.networks.map(n =>\n            <option key={n.id} value={n.id}>\n                {n.name}\n            </option>\n        );\n    }\n\n    render() {\n        const { network_id } = this.props;\n\n        return (\n            <div className=\"Header\">\n                <div className=\"top\">\n                    <div className=\"left\">\n                        <span className=\"h1\">\n                            <Link to=\"/\" className=\"main\">Thomas</Link>\n                        </span>\n                        &nbsp; A Bayesian Network viewer.\n                    </div>\n\n                    <div className=\"right\">\n                        <a\n                            href=\"https://github.com/mellesies/thomas-master\"\n                            target=\"_blank\"\n                            rel=\"noopener noreferrer\"\n                            >\n                            Github\n                        </a>\n                    </div>\n                </div>\n\n                <select onChange={this.onChange} value={network_id || ''}>\n                    <option disabled value=''> -- select Bayesian network -- </option>\n                    { this.renderOptions() }\n                </select>\n            </div>\n        );\n    }\n}","import React, { Component } from 'react';\nimport {\n    Group,\n    Rect,\n    Label,\n    Tag,\n    Text,\n} from 'react-konva';\n\nexport default class Node extends Component {\n\n    constructor(props) {\n        super(props);\n        this.RV = props.node.RV;\n\n        this.titleHeight = 15\n        this.stateOffset = 8\n        this.stateHeight = 14\n        this.statePadding = 2;\n\n        this.width = 180;\n        this.height = this.computeHeight();\n\n        const\n            x = props.node.position[0],\n            y = props.node.position[1];\n\n        // this requires height to be computed and sets:\n        //  - this.x, this.y\n        //  - this.center\n        //  - this.corners\n        this.setPosition(x, y);\n    }\n\n    onDragMove = (e) => {\n        const\n            x = e.target.x(),\n            y = e.target.y();\n\n        // console.log('onDragMove:', x, y);\n        this.setPosition(x, y);\n\n        if (this.props.onDragMove) {\n            this.props.onDragMove(this.RV, x, y);\n        }\n    }\n\n    onDragEnd = (e) => {\n        const\n            x = e.target.x(),\n            y = e.target.y();\n\n        if (this.props.onDragEnd) {\n            this.props.onDragEnd(this.RV, x, y);\n        }\n    }\n\n    onStateToggled = (state) => {\n        // console.log(`onStateToggled('${state}')`);\n        if (this.props.onStateToggled) {\n            this.props.onStateToggled(this.RV, state)\n        }\n    }\n\n    /**\n     * Create Labels for the individual states.\n     */\n    createStates(node, probabilities, query) {\n        const { width } = this;\n        const\n            label_width = 70,\n            probability_width = 55;\n\n        const remaining_width = width - label_width - probability_width;\n\n        // console.log('createStates', query);\n\n        return node.states.map((state, idx) => {\n            const y = (\n                this.titleHeight\n                + this.stateOffset\n                + idx * this.stateHeight\n            )\n\n            var probability = '...';\n            var bar_width = 0;\n            var bar_color = '#003366';\n\n            if (query && query === state) {\n                bar_color = '#00BCCC';\n            }\n\n            if (probabilities) {\n                probability = (100 * probabilities[state]).toFixed(2) + '%';\n                bar_width = 1 + remaining_width * probabilities[state]\n            }\n\n            return (\n                <Group\n                    key={state}\n                    y={y}\n                    >\n\n                    <Label>\n                        <Tag />\n                        <Text\n                            text={state}\n                            padding={this.statePadding}\n                            fontSize={this.stateHeight - this.statePadding}\n                            wrap=\"none\"\n                            ellipsis=\"ellipsis\"\n                            width={label_width}\n                            />\n                    </Label>\n\n                    <Rect\n                        x={label_width}\n                        y={1}\n                        width={bar_width}\n                        height={this.stateHeight - 2}\n                        fill={bar_color}\n                        />\n\n                    <Label x={width - probability_width}>\n                        <Tag />\n                        <Text\n                            text={probability}\n                            padding={this.statePadding}\n                            fontSize={this.stateHeight - this.statePadding}\n                            align=\"right\"\n                            wrap=\"none\"\n                            width={probability_width}\n                            />\n                    </Label>\n                </Group>\n            );\n        })\n    }\n\n\n    /**\n     * Compute and return the Node's height.\n     */\n    computeHeight() {\n        const { node } = this.props;\n\n        return (\n            node.states.length * this.stateHeight\n            + 2 * this.stateOffset\n            + this.titleHeight\n        );\n    }\n\n    /**\n     * Recompute center and corners.\n     *\n     * @param x (int): new x (top-left corner)\n     * @param y (int): new y (top-left corner)\n     */\n    setPosition(x, y) {\n        // console.log(`setPosition(${x}, ${y})`)\n        const { width, height } = this;\n\n        this.x = x;\n        this.y = y\n\n        this.center = {\n            x: x + width/2,\n            y: y + height/2\n        }\n\n        this.corners = {\n            'tl': {x: x, y: y},\n            'tr': {x: x + width, y: y},\n            'bl': {x: x, y: y + height},\n            'br': {x: x + width, y: y + height},\n        }\n    }\n\n    render() {\n        const { node, query, probabilities } = this.props;\n        const { x, y, width, height } = this;\n        const states = this.createStates(node, probabilities, query);\n\n        // Return the Node as a group.\n        return (\n            <Group\n                x={x}\n                y={y}\n                width={width}\n                height={height}\n                onDragMove={this.onDragMove}\n                onDragEnd={this.onDragEnd}\n                // onDblClick={(e) => console.log('onDblClick')}\n                draggable\n                >\n                {/* Background */}\n                <Rect\n                    fill=\"#efefef\"\n                    width={width}\n                    height={height}\n                    cornerRadius={5}\n                    shadowBlur={5}\n                    />\n\n                {/* Header */}\n                <Label>\n                    <Tag />\n                    <Text\n                        text={node.name}\n                        padding={4}\n                        fontSize={this.titleHeight}\n                        fontStyle=\"bold\"\n                        width={width}\n                        />\n                </Label>\n\n                {/* States */}\n                { states }\n            </Group>\n        )\n    }\n}","import axios from 'axios';\nimport createAuthRefreshInterceptor from 'axios-auth-refresh';\n\n\nclass Api {\n    constructor() {\n        this._axios = null;\n        this._user = false; }\n\n    /**\n     * Initialize the API.\n     */\n    init(config) {\n        // Setup axios to use JWT and automatically refresh if necessary.\n        const urlParams = new URLSearchParams(window.location.search)\n        const sessionToken = urlParams.get('session_token')\n    \n        this._config = {\n            withCredentials: true,\n            ...config\n        };\n        this._axios = axios.create(config);\n\n        this._axios.interceptors.request.use(request => {\n            request.params ={ session_token: sessionToken, ...request.params}\n            return request;\n        });\n\n        createAuthRefreshInterceptor(\n            this._axios,\n            (failedRequest) => this.refreshAuthLogic(failedRequest)\n        );\n\n        // Make axios.request available for flexibility\n        this.request = this._axios.request;\n    }\n\n\n\n    _request(config) {\n        console.log('Api::request()', config);\n        return this._axios.request(config).then(r => r.data);\n    }\n\n    /**\n     * Return the API version\n     */\n    getVersion() {\n        return this._request({\n            url: '/version',\n            method: 'GET',\n        });\n    }\n\n    getSession() {\n        return this._request({\n            url: '/session',\n            method: 'GET',\n            withCredentials: true,\n        });\n    }\n\n    getNetworks() {\n        console.log('Api::getNetworks()', );\n\n        return this._request({\n            url: '/network',\n            method: 'GET',\n        });\n    }\n\n    getNetwork(id) {\n        return this._request({\n            url: `/network/${id}`,\n            method: 'GET',\n            // params: {summary: false}\n        });\n    }\n\n    saveNetwork(id, network) {\n        return this._request({\n            url: `/network/${id}`,\n            method: 'POST',\n            data: network,\n        });\n    }\n\n    queryNetwork(id, parameters) {\n        var query = {\n            id: id,\n            query: {\n                ...parameters\n            }\n        };\n\n        return this._request({\n            url: `network/_query`,\n            // params: parameters,\n            data: query,\n            method: 'POST',\n        })\n    }\n}\n\nexport const api = new Api();\nexport default api;","import React, { Component } from 'react';\nimport {\n    Stage, Layer,\n    Arrow,\n} from 'react-konva';\n\n\nimport qs from 'qs';\n\nimport Node from './node';\n\nimport { arrayToDict } from '../util';\nimport { api } from '_api';\n\nimport './stylesheet.scss';\n\n\nfunction Edge({src, dst}) {\n    return (\n        <Arrow\n            x={0}\n            y={0}\n            points={[src.x, src.y, dst.x, dst.y]}\n            pointerLength={10}\n            pointerWidth={10}\n            fill={'black'}\n            stroke={'black'}\n            strokeWidth={2}\n            />\n    )\n}\n\nfunction getNodeNamesFromNetwork(network) {\n    return network.nodes.map(node => node.RV);\n}\n\n// line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/\n// Determine the intersection point of two line segments\n// Return FALSE if the lines don't intersect\n// Alternative implementations at:\n// - http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n// - https://stackoverflow.com/questions/13937782/calculating-the-point-of-intersection-of-two-lines\n//\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\n    // Check if none of the lines are of length 0\n    if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n        console.warn('Found line of length 0');\n        return false\n    }\n\n    var denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))\n\n    // Lines are parallel\n    if (denominator === 0) {\n        console.warn('Denominator is zero 0');\n        return false\n    }\n\n    let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator\n    let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator\n\n    // is the intersection along the segments\n    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n        // console.debug('Intersection outside segments');\n        return false\n    }\n\n    // Return an object with the x and y coordinates of the intersection\n    let x = x1 + ua * (x2 - x1)\n    let y = y1 + ua * (y2 - y1)\n\n    return {x, y}\n}\n\nfunction compute_intersection(corners, line) {\n    const points = [\n        ['tl', 'tr'],\n        ['tl', 'bl'],\n        ['tr', 'br'],\n        ['bl', 'br'],\n    ];\n\n    var intersection = false;\n\n    for (const p of points) {\n        const key1 = p[0], key2 = p[1];\n\n        intersection = intersect(\n            corners[key1].x,\n            corners[key1].y,\n            corners[key2].x,\n            corners[key2].y,\n            line.src.x,\n            line.src.y,\n            line.dst.x,\n            line.dst.y,\n        );\n\n        if (intersection) {\n            break;\n        }\n    }\n\n    if (!intersection) {\n        console.warn('Could not determine intersection');\n    }\n\n    return intersection;\n}\n\nexport default class Network extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            network: null,\n            first_pass_complete: false,\n            node_centers: {},\n            node_corners: {},\n            query: {},\n            probabilities: {},\n        }\n\n        this.myRefs = {};\n    }\n\n    componentDidMount() {\n        // this.updateFromQueryParameters();\n        // This will trigger downloading the network JSON.\n        this.setNetwork();\n\n    }\n\n    componentDidUpdate() {\n        // console.log(\"*** NETWORK DID UPDATE! ***\")\n        const { network, first_pass_complete } = this.state;\n\n        if (network && !first_pass_complete) {\n            // this.myRefs is set and each ref.current points to a <Node>.\n            // Triggers setState().\n            this.nodeAttrsToState();\n\n            // Update this.state.query from the URL\n            // Triggers setState().\n            this.updateFromQueryParameters();\n        }\n    }\n\n    updateFromQueryParameters() {\n        // Parse the URL to determine query parameters.\n        var q = qs.parse(\n            this.props.location.search,\n            { ignoreQueryPrefix: true }\n        );\n\n        // Only keep those entries in 'q' that correspond to a valid state.\n        const { network } = this.state;\n        const nodes = arrayToDict(network.nodes, 'RV');\n        const query = {};\n\n        for (const [RV, node] of Object.entries(nodes)) {\n            // console.log(`${RV}:`, node);\n            if (q[RV] && node.states.includes(q[RV])) {\n                query[RV] = q[RV];\n            }\n        }\n\n        // Triggers setState() when query resolves.\n        this.query(query);\n    }\n\n    setNetwork() {\n        // download network & set state\n        const { network_id } = this.props;\n        console.log(this.props)\n        api.getNetwork(network_id).then((response) => {\n            const network = response.json;\n            network.id = network_id;\n            console.log(network_id)\n            this.setState({ network })\n        })\n    }\n\n    query(query) {\n        console.log('Network::query()', query);\n        const id = this.state.network.id;\n\n        api.queryNetwork(id, query).then(r => {\n            // console.log('Network::query(): ', r)\n            this.setState({\n                query: r.query,\n                probabilities: r.probabilities,\n            })\n        })\n    }\n\n    /**\n     * Iterate over <Node>'s rendered and retrieve their corners and centers.\n     */\n    nodeAttrsToState() {\n        const nodenames = getNodeNamesFromNetwork(this.state.network);\n        const\n            node_centers = {},\n            node_corners = {};\n\n        for (const name of nodenames) {\n            var node = this.myRefs[name].current;\n\n            // node.center and node.corners are set in Node.render()\n            node_centers[name] = node.center;\n            node_corners[name] = node.corners;\n        }\n\n        this.setState({\n            first_pass_complete: true,\n            node_centers,\n            node_corners,\n        });\n    }\n\n    /**\n     * Return the line (coordinates) between two nodes' centers, taking the\n     * nodes' edges into account.\n     */\n    computeEdge(srcRV, dstRV) {\n        const { node_centers, node_corners } = this.state;\n\n        const\n            src_center = node_centers[srcRV],\n            dst_center = node_centers[dstRV];\n\n        const\n            src_corners = node_corners[srcRV],\n            dst_corners = node_corners[dstRV];\n\n        const src_intersection = compute_intersection(\n            src_corners,\n            {src: src_center, dst: dst_center}\n        );\n\n        const dst_intersection = compute_intersection(\n            dst_corners,\n            {src: src_center, dst: dst_center}\n        );\n\n        return {\n            src: src_intersection,\n            dst: dst_intersection,\n        }\n    }\n\n    /**\n     * Triggered by Node for each update to its position.\n     */\n    onNodeMove = (RV, x, y) => {\n        // console.log('Network::onNodeMove()', RV);\n        this.nodeAttrsToState();\n    }\n\n    /**\n     * Triggered by Node after dragging has stopped.\n     */\n    onNodeMoved = (RV, x, y) => {\n        // console.log(`Network::onNodeMoved('${RV}', ${x}, ${y})`);\n        const network = { ...this.state.network };\n        const { network_id } = this.props;\n\n        for (const node of network.nodes) {\n            if (node.RV === RV) {\n                node.position = [x, y];\n                break\n            }\n        }\n\n        // Save the network.\n        api.saveNetwork(network_id, network);\n    }\n\n    onStateToggled = (RV, state) => {\n        // console.log(`onStateToggled('${RV}', '${state}')`);\n        const q = { ...this.state.query };\n\n        if (q[RV] && q[RV] === state) {\n            delete q[RV];\n        } else {\n            q[RV] = state;\n        }\n\n        // Update the URL query parameters\n        this.props.history.push({\n            pathname: '',\n            search: \"?\" + new URLSearchParams({...q}).toString()\n        })\n\n        // Query the network.\n        // Triggers setState() when query resolves.\n        // this.query(q);\n    }\n\n    renderEdges() {\n        const { network } = this.state;\n\n        return network.edges.map(e => {\n            const\n                srcRV = e[0],\n                dstRV = e[1];\n\n            const {src, dst} = this.computeEdge(srcRV, dstRV);\n\n            // console.log('Creating Edge: src:', src, 'dst:', dst);\n            return (\n                <Edge\n                    key={`${srcRV}_${dstRV}`}\n                    src={src}\n                    dst={dst}\n                    />\n            )\n        })\n    }\n\n    renderLoading() {\n        return (\n            <div className=\"Network\">\n                <span>Loading ...</span>\n            </div>\n        )\n    }\n\n    render() {\n        // console.log('match:', this.props.match);\n        // console.log('location:', this.props.location);\n        // console.log('qs:', qs.parse(this.props.location.search, { ignoreQueryPrefix: true }));\n\n        // const { network, network_id } = this.props;\n        // const { network_id } = this.props;\n\n        const { network } = this.state;\n\n        if (!network) {\n            // Apparently we haven't downloaded the network yet.\n            return this.renderLoading();\n        }\n\n        const {\n            first_pass_complete,\n            query,\n            probabilities,\n        } = this.state;\n        const { myRefs } = this;\n\n        // Create an ordered list of node names\n        // const nodenames = network.nodes.map(node => node.RV);\n        const nodenames = getNodeNamesFromNetwork(network);\n\n        // Create a dict of nodes, indexed by node.RV\n        const nodes = network.nodes.reduce(\n            (a, node) => {\n                a[node.RV] = node;\n                return a;\n            },\n            {}\n        );\n\n        return (\n            <div className=\"Network\">\n                {/*<Toolbar network={network} />*/}\n\n                <div className=\"KonvaContainer\">\n                    <Stage width={2042} height={1024}>\n                        <Layer>\n                            {first_pass_complete && this.renderEdges()}\n\n                            {nodenames.map(RV => {\n                                // console.log('RV: ', RV, this);\n                                myRefs[RV] = React.createRef();\n\n                                return (\n                                    <Node\n                                        ref={myRefs[RV]}\n                                        key={RV}\n                                        node={nodes[RV]}\n                                        query={query[RV]}\n                                        probabilities={probabilities[RV]}\n                                        onDragMove={this.onNodeMove}\n                                        onDragEnd={this.onNodeMoved}\n                                        onStateToggled={this.onStateToggled}\n                                        />\n                                )\n                            })}\n                        </Layer>\n                    </Stage>\n                </div>\n            </div>\n        )\n    }\n}\n","\n\nconst arrayToDict = (array, key) =>\n  array.reduce((obj, item) => ({ ...obj, [item[key]]: item }), {})\n;\n\nexport { arrayToDict };","import React, { Component } from 'react';\n\nimport Header from 'header';\nimport Network from 'network';\n\nimport './stylesheet.scss';\n\n\nexport default class Main extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            networks: [\n                {\n                    \"resourceType\": \"Network\",\n                    \"_id\": \"/network/rectalcancer\",\n                    \"_links\": {\n                        \"_self\": \"/network/rectalcancer\",\n                        \"_collection\": \"/network\",\n                        \"owner\": \"/user/1\"\n                    },\n                    \"_excluded\": [\n                        \"json\"\n                    ],\n                    \"id\": \"rectalcancer\",\n                    \"name\": \"Rectal cancer\"\n                }\n                    ],\n        }\n    }\n\n\n    render() {\n        var { networks } = this.state;\n\n        return (\n            <div className=\"Main\">\n                <Header\n                    networks={networks}\n                    network_id={\"rectalcancer\"}\n                    onNetworkSelected={this.onNetworkSelected}\n                    {...this.props}\n                    />\n\n                    <Network\n                        key={\"/network/rectalcancer\"}\n                        network_id={\"rectalcancer\"}\n                        {...this.props}\n                    />\n\n            </div>\n        )\n    }\n}\n","import React, { Component } from 'react';\nimport {\n  Switch,\n  Route,\n} from \"react-router-dom\";\n\n// import Header from 'header';\n\nimport Footer from 'footer';\nimport Main from 'main';\n\nimport './App.scss';\n\n\nexport default class App extends Component {\n\n    render() {\n        return (\n            <div className=\"App\">\n                <Switch>\n                    <Route path=\"\" component={Main}/>\n                </Switch>\n                <Footer />\n            </div>\n        );\n    }\n}\n","\n// API\nconst api_config = {};\n\nconst urlParams = new URLSearchParams(window.location.search)\nconst host = urlParams.get('invocation_host')\nconst port = urlParams.get('invocation_port')\napi_config['baseURL'] = `${host}:${port}`;\n\nexport { api_config };\n\n// LOCALE\nexport const locale_config = {\n    language: '',\n    locale: '',\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\n\n\nimport './index.css';\n\nimport App from './App';\nimport { api } from '_api';\nimport { api_config } from 'config.js';\n\nimport * as serviceWorker from './serviceWorker';\n\n// console.log('api_config:', api_config);\n// console.log(config.api_url);\napi.init(api_config);\n\nReactDOM.render(\n    <Router basename=\"/app\">\n        <Switch>\n            <Route\n                path=\"/\"\n                component={App}\n                />\n        </Switch>\n    </Router>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}